<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rover</title>

</head>
<body>
    <h1>Hello World</h1>
    <h2 id="status"></h2>
    
  

   
    
    <script type="text/javascript" src="//patrila.app:5000/socket.io/socket.io.js"></script>
    <script type="text/javascript" src="//patrila.app:5001/assets/js/streamify.js"></script>

    <script>

        const statusDisplay = document.getElementById('status');

        //Initialize two sockets
        let local,broker;

        try{

            local  = io('ws://localhost:3000');
            broker = io("wss://patrila.app:5000");

        }catch(err){

            //Restart
            setTimeout(()=>{
                documen.location.reload();
            },5000);

            throw err;
        };
        
        //Initialize state
        let state = {
            name:'TOURTRON_1',
            status:'ready',
            time:(new Date).getTime()
        };

        function updateState(data){

            for(let key in state){
                if(typeof data[key] != 'undefined'){
                    state[key] = data[key];
                } 
            }
        }


        let broadcast = null;
        /**
        local.on('connect',()=>{
            console.log('Local server connected');
        });

        //If local server was disconnected
        local.on('disconnected',()=>{
            console.log('Disconnected');
            //Stop the stream
            if(broadcast != null){
                broadcast.stopStream();
            }

            updateState({
                status:'ready',
                time:(new Date()).getTime()
            });

            broker.volatile.emit('rover-not-responding');
        });
        **/
        broker.on('connect',()=>{

            let pendingFlag = false;

            setInterval(()=>{

                let now = (new Date()).getTime();
                
                //If state is ready inform broker
                if(state.status == 'ready'){
                    pendingFlag = false;
                    broker.volatile.emit('status',state);
                }

                
                //If pending status has not change in more or equal to 10 seconds
                if(state.status == 'pending' && (now - state.time) >= 10000 && !pendingFlag){

                    pendingFlag = true;

                    console.log('pending stuff')
                    //Stop the stream
                    if(broadcast != null){
                        broadcast.stopStream();
                    }
                    
                    updateState({
                        status:'ready',
                        time:(new Date()).getTime()
                    });

                    broker.volatile.emit('rover-not-responding');
                    
                    //Stop movement
                    local.emit('stop');
                }
                

            },3000);
        
        });
       
        
        //If there is a status update
        broker.on('status',(data)=>{
            console.log('status',data);
            updateState({
                status:data.status,
                time:(new Date()).getTime()
            });
        });


        //If a client wants to connect
        broker.on('connection-request',(data)=>{
            console.log('connection-request',data);

            //Update rover state to pending
            updateState({
                status:'pending',   
                time:(new Date()).getTime()
            });

            getMediaCaptureDevices().then(media=>{
             
                broadcastStream({
                    camera: media.video[0].id,
                    microphone: media.audio[0].id,
                    socket:broker,
                    clientSocketId:data.clientId,
                    state:state
                }).then((bcast)=>{

                    broadcast = bcast;
                    console.log('done');
                }).catch(err=>{
                    
                    updateState({
                        status:'ready',
                        time:(new Date()).getTime()
                    });

                    broker.volatile.emit('rover-broadcast-failed',state.name,data.clientId,'Rover cannot connect to client');
                    local.emit('stop');
                    console.log('Error',err);
                });

            }).catch(err=>{

                updateState({
                    status:'ready',
                    time:(new Date()).getTime()
                });
                
                broker.volatile.emit('rover-broadcast-failed',state.name,data.clientId,'Cannot access camera or microphone');
                local.emit('stop');
                console.log('ERROR',err);
            });
        });

        //if client got disconnected
        broker.on('client-disconnected',()=>{
            console.log('Client disconneced');
            //Stop the stream
            if(broadcast != null){
                console.log('boradcast',broadcast);
                broadcast.stopStream();
            }
            
            //Stop movement
            local.emit('stop');

            updateState({
                status:'ready',
                time:(new Date()).getTime()
            });
            
        });
        
        //local
        let lastCommand;
        
        let localDelay = 2000;
        /**
        broker.on('forward',()=>{
            
            clearInterval(lastCommand);
            
            local.volatile.emit('forward');
            
            statusDisplay.innerHTML = 'FORWARD';

            lastCommand = setTimeout(()=>{
                local.volatile.emit('stop');
            },localDelay);
        });

        broker.on('backward',()=>{
            clearInterval(lastCommand);
            
            local.volatile.emit('backward');

            statusDisplay.innerHTML = 'BACKWARD';
            lastCommand = setTimeout(()=>{
                local.volatile.emit('stop');
            },localDelay);
        });

        broker.on('rotate-left',()=>{
            clearInterval(lastCommand);
            
            local.volatile.emit('rotate-left');

            statusDisplay.innerHTML = 'ROTATE LEFT';
            lastCommand = setTimeout(()=>{
                local.volatile.emit('stop');
            },localDelay);
        });

        broker.on('rotate-right',()=>{
            clearInterval(lastCommand);
            
            local.volatile.emit('rotate-right');

            statusDisplay.innerHTML = 'ROTATE RIGHT';
            lastCommand = setTimeout(()=>{
                local.volatile.emit('stop');
            },localDelay);
        });

        broker.on('stop',()=>{
            clearInterval(lastCommand);
            
            local.volatile.emit('stop');

            statusDisplay.innerHTML = 'STOP';
            lastCommand = setTimeout(()=>{
                local.volatile.emit('stop');
            },localDelay);
        });


        **/

    </script>



   
</body>
</html>